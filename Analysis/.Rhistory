citation()
x <- c(8, 0)
n <- c(27,15)
prop.test(x,n)
x <- c(8, 15)
n <- c(27,72)
prop.test(x,n)
57+15
47/ (15**24*7)
47/ (15*24*7)
47/ (15)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
# Recode facet z-values into color indices
facetcol <- cut(zfacet, nbcol)
persp(x, y, z, col=color[facetcol], phi=30, theta=-30)
par(op)
dim(zfacet)
dim(z)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
nrz <- nrow(z)
ncz <- ncol(z)
jet.colors <- colorRampPalette( c("blue", "green") )
nbcol <- 100
color <- jet.colors(nbcol)
zfacet <- z
facetcol <- cut(zfacet, nbcol)
persp(x, y, z, col=color[facetcol], phi=30, theta=-30)
par(op)
facetcol
class(facetcol)
nbcol
color
?cut
dim(color)
head(facetcol)
head(z)
dim(z)
z[1:10,1:10]
z[1:10,1:7]
zfacet[1:10,1:7]
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
zfacet[1:10,1:7]
z
zfacet[1:10,1:7]
z[1:10,1:7]
z[-1, -1]
tmp <- z[-1, -1]
dim(tmp)
tmp <- z[-1, -ncz]
dim(tmp)
packmates<-c(0,seq(1:15))
infected<-c(0,seq(1:10))
storage<-mat.or.vec(16,11)
par(mfrow=c(1,2))
pp1b <- data.frame(Mangy=1,ElkWolfRatio=(mean(Data2005$ElkWolfRatio, na.rm=T)),  AvgT3=mean(Data2005$AvgT3, na.rm=T),   MoN = 49)# toggle Mangy=0/1 to see different predictions based on indivdiual mange status
for(i in seq(1, length(packmates))){
pp1b$PackSize<-packmates[i]
for(j in seq(1, length(infected))){
pp1b$NumInfected23<-infected[j]
pr.modp1b<-predict(c3h, newdata = pp1b, se = T, type = 'response')
storage[i,j]<-pr.modp1b$fit
}}
for(i in seq(1, length(packmates))){
tmp<-which(infected>packmates[i])
storage[i, tmp]<-NA
}
pp1b <- data.frame(Mangy=1,ElkWolfRatio=1,  AvgT3=10,   MoN = 49)# toggle Mangy=0/1 to see different predictions based on indivdiual mange status
for(i in seq(1, length(packmates))){
pp1b$PackSize<-packmates[i]
for(j in seq(1, length(infected))){
pp1b$NumInfected23<-infected[j]
pr.modp1b<-predict(c3h, newdata = pp1b, se = T, type = 'response')
storage[i,j]<-pr.modp1b$fit
}}
?persp
x <- seq(-10, 10, length= 30)
y <- x
f <- function(x, y) { r <- sqrt(x^2+y^2); 10 * sin(r)/r }
z <- outer(x, y, f)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = "X", ylab = "Y", zlab = "Sinc( r )"
) -> res
round(res, 3)
x <- seq(-10, 10, length= 30)
y <- x
f <- function(x, y) { r <- sqrt(x^2+y^2); 10 * sin(r)/r }
z <- outer(x, y, f)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = "X", ylab = "Y", zlab = "Sinc( r )"
) -> res
round(res, 3)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
xE <- c(-10,10); xy <- expand.grid(xE, xE)
points(trans3d(xy[,1], xy[,2], 6, pmat = res), col = 2, pch = 16)
lines (trans3d(x, y = 10, z = 6 + sin(x), pmat = res), col = 3)
phi <- seq(0, 2*pi, len = 201)
r1 <- 7.725 # radius of 2nd maximum
xr <- r1 * cos(phi)
yr <- r1 * sin(phi)
lines(trans3d(xr,yr, f(xr,yr), res), col = "pink", lwd = 2)
z <- 2 * volcano        # Exaggerate the relief
x <- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
## Don't draw the grid lines :  border = NA
par(bg = "slategray")
persp(x, y, z, theta = 135, phi = 30, col = "green3", scale = FALSE,
ltheta = -120, shade = 0.75, border = NA, box = FALSE)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue", ltheta = -120)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue", scale = F)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue", border  = NA)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "green3", shade = .75, border  = NA)
facetcol
dim(facetcol)
dim(color)
class(facetcol)
length(facetcol)
30*35
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
color.new
length(colornew)
length(color.new)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
#zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
zfacet <- z
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
length(color.new)
rm.cells <- which(z > -4)
rm.cells
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
#zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
zfacet <- z
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
rm.cells <- which(z > -4)
color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30)
par(op)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
rm.cells <- which(z > -4)
color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color.new, phi=30, theta=-30)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
rm.cells <- which(z > -2)
color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color.new, phi=30, theta=-30)
par(op)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
rm.cells <- which(z > -1)
color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color.new, phi=30, theta=-30)
par(op)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
color.new <- color[facetcol]
rm.cells <- which(z > -1)
color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color.new, phi=30, theta=-30, border = NA)
?which
length(rm.cells)
length(color.new)
length(facetcol)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 30)
y <- seq(-1.95, 1.95, length = 35)
z <- outer(x, y, function(a,b) a*b^2)
z[z>-2] <- NA
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
#color.new <- color[facetcol]
#rm.cells <- which(z > -1)
#color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30, border = NA)
summary(z)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 50)
y <- seq(-1.95, 1.95, length = 50)
z <- outer(x, y, function(a,b) a*b^2)
z[z>-1] <- NA
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
#color.new <- color[facetcol]
#rm.cells <- which(z > -1)
#color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30, border = NA)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 50)
y <- seq(-1.95, 1.95, length = 50)
z <- outer(x, y, function(a,b) a*b^2)
z[ z >-0] <- NA
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
#color.new <- color[facetcol]
#rm.cells <- which(z > -1)
#color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30, border = NA)
par(bg = "white")
x <- seq(-1.95, 1.95, length = 50)
y <- seq(-1.95, 1.95, length = 50)
z <- outer(x, y, function(a,b) a*b^2)
z.na <- outer(x, y, function(a,b) a-b)
na.cells <- which(z.na >0)
z[na.celss] <- NA
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
#color.new <- color[facetcol]
#rm.cells <- which(z > -1)
#color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30, border = NA)
z[na.cells] <- NA
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
facetcol <- cut(zfacet, nbcol)
#color.new <- color[facetcol]
#rm.cells <- which(z > -1)
#color.new[rm.cells] <- "grey77"
persp(x, y, z, col=color[facetcol], phi=30, theta=-30, border = NA)
par(op)
setwd("~/BitBucket/VIT2014/Analysis")
rm(list = ls())
source('VITplot_interval2.r')
library(lubridate)
Data <- read.table("VIT_Data2014.txt", sep="", header=T) #load in data
# reformat some of the dates
Data$CaptureDate <- mdy(as.character(Data$CaptureDate))
Data$Start_Interval <- mdy(as.character(Data$Start_Interval))
Data$Stop_Interval <- mdy(as.character(Data$Stop_Interval))
# insert death dates on mothers that died
Data$Stop_Interval[Data$VIT_Status == "Died"] <- Data$Start_Interval[Data$VIT_Status == "Died"]
# make the dates an integer for indexing purposes.
Data$CapDOY <- yday(Data$CaptureDate) # day of the capture (1-365)
Data$StartDOY <- yday(Data$Start_Interval) # day when the VIT is first possibly out
Data$EndDOY <- yday(Data$Stop_Interval) # last day the event (birth or abortion) could have happened
Data$interval1 <- Data$StartDOY - Data$CapDOY # days from capture to the time when the VIT is first possibly out of the animal
Data$interval2 <- Data$EndDOY - Data$StartDOY # first to last day that the event could have happened.
Data$TrustRating <- as.factor(Data$TrustRating)
head(Data)
summary(Data)
summary(Data$VIT_Status)
# Table of effort per year
table(year(Data$CaptureDate))
table(year(Data$CaptureDate), Data$VIT_Status) # most of the unknowns happened early on.
# Table of event types by trust rating
table(Data$VIT_Status, Data$TrustRating)
# Look at the Unknowns
Data[Data$VIT_Status == "Unknown", c(1:5, 11)]
Data <- subset(Data, Data$VIT_Status != "Open" ) # remove non-pregnants
Data <- subset(Data, Data$VIT_Status != "Unknown" ) # remove unknowns
Data <- subset(Data, is.na(Data$StartDOY) != T )
summary(Data$VIT_Status)
table(year(Data$CaptureDate))
summary(Data)
which(Data$interval1 == 0 )
which(Data$interval2 == 0 )
DataPOS <- subset(Data, Data$CowSero == "POS")
which(DataPOS$interval2 == 0 )
which(DataPOS$interval1 == 0 )
# Code to run the vit hazard spline models
setwd("~/BitBucket/VIT2014/Analysis")
rm(list = ls())
library(R2WinBUGS)
library(R2jags)
source("Z_foo.r") # fxn for calculating Z on the splines
source("plot_VITresults_fxns.r") # fxns for plotting model results
source("Write_VITSplineInterval.r") # code for the BUGS models
seroyes <- 0
if(seroyes == 1){load('VIT_Data2014_Full_POS.RData')}
if(seroyes != 1){load('VIT_Data2014_Full.RData')}
right-left
which(right - left == 0 )
seroyes <- 1
if(seroyes == 1){load('VIT_Data2014_Full_POS.RData')}
if(seroyes != 1){load('VIT_Data2014_Full.RData')}
which(right - left == 0 )
seroyes <- 0
if(seroyes == 1){load('VIT_Data2014_Full_POS.RData')}
if(seroyes != 1){load('VIT_Data2014_Full.RData')}
Data[358,]
# Code to run the vit hazard spline models
setwd("~/BitBucket/VIT2014/Analysis")
rm(list = ls())
library(R2WinBUGS)
library(R2jags)
source("Z_foo.r") # fxn for calculating Z on the splines
source("plot_VITresults_fxns.r") # fxns for plotting model results
source("Write_VITSplineInterval.r") # code for the BUGS models
seroyes <- 0
if(seroyes == 1){load('VIT_Data2014_Full_POS.RData')}
if(seroyes != 1){load('VIT_Data2014_Full.RData')}
which(right - left == 0 )
exp(0)
exp(1)
log(1)
exp(4)
exp(1)
log(4.5)
log(0)
log(1)
log(.1)
